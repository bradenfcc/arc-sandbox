#!/usr/bin/env node

'use strict'
const { program } = require('commander');
const fs = require('fs')
const dump = require('./dump')
const help = require('./help')
const init = require('./init')
const latest = require('./latest')
const migrate = require('./migrate')
const rebuild = require('./rebuild')
const repo = require('./repo')
const version = require('./version')
const zip = require('./zip')
const {
  cleanContainers,
  cleanImages,
  cleanNetworks,
  cleanVolumes,
  nuke
} = require('./clean')

const {
  build,
  daemon,
  down,
  generate,
  run,
  start,
  stop
} = require('../utils/docker')

async function showVersionAndRelease () {
  version()
  await latest()
  run('release')
}

program
  .option('-n, --no-admin','Start up fusion without admin')

program
  .command('build')
  .description('Build Fusion images')
  .action(async ()=>{
    await generate()
    await build()
  })


program
  .command('clean')
  .description('Clear stray docker artifacts')
  .action(async ()=>{
    await nuke();
  })


program
  .command('cleanContainers')
  .description('Clear stray docker containers')
  .action(async ()=>{
    await cleanContainers();
  })


program
  .command('cleanImages')
  .description('Clear stray docker images')
  .action(async ()=>{
    await cleanImages();
  })


program
  .command('cleanNetworks')
  .description('Clear stray docker networks')
  .action(async ()=>{
    await cleanNetworks();
  })


program
  .command('cleanVolumes')
  .description('Clear stray docker volumes')
  .action(async ()=>{
    await cleanVolumes();
  })


program
  .command('daemon')
  .description('Run Fusion services in detached mode')
  .action(async ()=>{
    await generate()
    await down()
    await build()
    await daemon()
  })
  
program
  .command('down')
  .description('Stop and remove Fusion services and volumes')
  .action(async ()=>{
    await generate()
    await down()
  })

program
  .command('dump')
  .description('Create a dump of the current DB in the data/dumps/ folder')
  .action(async ()=>{
    await dump();
  })

program
  .command('generate')
  .description('Generate a docker-compose.yml file for the current environment')
  .action(async function(options) {
    console.log(options)
    await generate('', { noAdmin: options.noAdmin })
  })
program
  .command('help')
  .description('Display description for each of available commands')
  .action(async function() {
    await help();
  })

program
  .command('init')
  .description('Bootstrap a new Fusion repository')
  .action(async ()=>{
    await init();
  })

program
  .command('migrate')
  .description("Rename component files with a trailing 'x' to prepare for 2.1 refactor")
  .action(async ()=>{
    await migrate();
  })

program
  .command('nuke')
  .description('Clear stray docker artifacts')
  .action(async ()=>{
    await nuke();
  })

program
  .command('rebuild')
  .description('Manually trigger webpack to rebuild after a change if file watching fails')
  .action(async ()=>{
    await rebuild();
  })

program
  .command('repo')
  .description('Print the name of the repository')
  .action(async ()=>{
    await repo()
  })

program
  .command('start [service]')
  .description('Start named fusion local development environment, or default if no name supplied')
  .option('-l, --links [blocks]', 'Link all blocks specified in blocks, devBlocks array, or a comma separated string of block names')
  .option('-p, --production', 'Use production blocks even if useLocal is set to true')
  .option('-f, --rebuild', 'Force rebuild of webpack image')
  .action(async (service, options) => {
    try {
      await latest()
      await generate(undefined, options)
      await down()
      await build()
      await start()
    } catch (e) {
      console.log(e);
      throw new Error('There was an error starting local fusion environment');
    } finally {
      await down()
    }
  })

program
  .command('Stop')
  .description('Stop Fusion docker services')
  .action(async () => {
    await generate()
    await stop()
  })

program
  .command('verify')
  .description('Verify the current bundle')
  .action(async () => run('verify'))

program
  .command('version')
  .description('Look at the version of fusion')
  .action(async () => {
    showVersionAndRelease();
  })

program
  .command('zip [service] [version]')
  .description('Create a bundle zip file in dist/ folder')
  .action(async (service, version = 'latest') => {
    console.log(service);
    if(service === 'theme') {
      // Copy blocks.json to a new file, modify the original copy with the versioning,
      // and zip, then replace with the original file
      fs.copyFileSync('./blocks.json', './blocks-copy.json');
      console.log(`Zipping the themes bundle with ${version} version of blocks`)

      const jsonData = fs.readFileSync('blocks.json')
      const jsonObj = JSON.parse(jsonData);

      // Strip versions from each of the blocks, and replace with @<version>
      for(let i = 0; i < jsonObj.blocks.length; i+=1) {
        let blockArr = jsonObj.blocks[i].split('@').slice(0, 2);
        blockArr.push(version)
        let blockName = blockArr.join('@')
        jsonObj.blocks[i] = blockName;
      }

      // Format it to a human-readable form
      var jsonContent = JSON.stringify(jsonObj, null, 2);

      await fs.writeFileSync('blocks.json', jsonContent);

      await run('verify')
      await zip();

      // Restore original copy of the blocks.json
      fs.copyFileSync('blocks-copy.json', 'blocks.json');
      fs.unlinkSync('blocks-copy.json');

    } else {
      await run('verify')
      await zip();
    }
  })

program.parse(process.argv);
